%% ASEN 3111 - Computational Assignment 1 - Main
% Provide a breif summary of the problem statement and code so that
% you or someone else can later understand what you attempted to do
% it doesnâ€™t have to be that long.
%
% Author: Thomas Dunnington
% Collaborators: Nolan Stevenson
% Date: 1/17/2023

%Clean Up
close all; clear; clc;

%% Problem 1
fprintf("-----------Problem 1-----------\n");

%Symbolic integration to determine the sectional lift and drag coefficients
    %%%%Double check that it is ok to have the symbolic implementation
cl = 2*pi;
cd = 0;
fprintf("Analytical sectional lift and drag coefficients:\n\t cl: 2\x03c0 \n\t cd: 0\n");

%%%%Numerical integration with the trapezoidal composite method
%Anonymous function for the coefficient of pressure with the given
%circulation
Cl_int = @(th)(2*(sin(th).^3 + sin(th).^2));
Cd_int = @(th)(2*(cos(th).*(sin(th).^2 + sin(th))));

%Computing the coefficient 50 times from 1 to 50 discretizations of the
%cylinder
N = 1:10; %The number of panels

%Storing the value of the integrations
Cl_int_trapz = zeros(length(N),1);
Cd_int_trapz = zeros(length(N),1);

%Storing the relative error
trapzRelError = zeros(length(N),1);

%Looping through different N values
for i = N
    Cl_int_trapz(i) = trapzFunc(Cl_int, [0 2*pi], i);
    Cd_int_trapz(i) = trapzFunc(Cd_int, [0 2*pi], i);
    
    %Calculating the relative error
    trapzRelError(i) = ((Cl_int_trapz(i) - double(cl)) / double(cl)) * 100;
end


%%%%Numerical Integration with the simpson's composite method
test = simpFunc(Cl_int, [0 2*pi], 10);

%Storing the value of the integrations
Cl_int_simp = zeros(length(N),1);
Cd_int_simp = zeros(length(N),1);

%Storing the relative error
simpRelError = zeros(length(N),1);

%Looping through different N values
for i = N
    Cl_int_simp(i) = simpFunc(Cl_int, [0 2*pi], i);
    Cd_int_simp(i) = simpFunc(Cd_int, [0 2*pi], i);
    
    %Calculating the relative error
    simpRelError(i) = ((Cl_int_simp(i) - double(cl)) / double(cl)) * 100;
end




%%%%Plotting
%%%%Trapz
figure();
set(0, 'defaulttextinterpreter', 'latex');
%Cl versus N discretizations
plot(N, double(cl)*ones(length(N),1), 'color', 'g', 'linewidth', 2)
grid on
hold on
plot(N, Cl_int_trapz, 'linewidth', 2, 'linestyle', 'none', 'marker', '.', 'markersize', 15, 'color', 'k');

xlabel('Number of Panels to Discretize');
ylabel('Sectional Lift Coefficient $$cl$$');
title('Sectional Lift Coefficient versus Number of Panels Trapezoid');
legend('Analytical Integration', 'Numerical Integration', 'location', 'se');

figure();
%Cd versus N discretizations
plot(N, double(cd)*ones(length(N),1), 'color', 'g', 'linewidth', 2)
grid on
hold on
plot(N, Cd_int_trapz, 'linewidth', 2, 'linestyle', 'none', 'marker', '.', 'markersize', 15, 'color', 'k');

xlabel('Number of Panels to Discretize');
ylabel('Sectional Drag Coefficient $$cd$$');
title('Sectional Drag Coefficient versus Number of Panels Trapezoid');
legend('Analytical Integration', 'Numerical Integration', 'location', 'se');


%%%%Simpz
figure();
set(0, 'defaulttextinterpreter', 'latex');
%Cl versus N discretizations
plot(N, double(cl)*ones(length(N),1), 'color', 'g', 'linewidth', 2)
grid on
hold on
plot(N, Cl_int_simp, 'linewidth', 2, 'linestyle', 'none', 'marker', '.', 'markersize', 15, 'color', 'k');

xlabel('Number of Panels to Discretize');
ylabel('Sectional Lift Coefficient $$cl$$');
title('Sectional Lift Coefficient versus Number of Panels Simpsons');
legend('Analytical Integration', 'Numerical Integration', 'location', 'ne');

figure();
%Cd versus N discretizations
plot(N, double(cd)*ones(length(N),1), 'color', 'g', 'linewidth', 2)
grid on
hold on
plot(N, Cd_int_simp, 'linewidth', 2, 'linestyle', 'none', 'marker', '.', 'markersize', 15, 'color', 'k');

xlabel('Number of Panels to Discretize');
ylabel('Sectional Drag Coefficient $$cd$$');
title('Sectional Drag Coefficient versus Number of Panels Simpsons');
legend('Analytical Integration', 'Numerical Integration', 'location', 'ne');


%%%%Printing thet minimum N required to get below 1% relative error
%Looping through and finding the first index where the error is less than 1
%percent

%Trapz
j = 1;
while(abs(trapzRelError(j)) > 1)
    %Updating iterator
    j = j + 1;
end

%Required panels for less than 1 percent relative error
trapzN = j;

%Simp
j = 1;
while(abs(simpRelError(j)) > 1)
    %Updating iterator
    j = j + 1;
end

%Required panels for less than 1 percent relative error
simpN = j;

%Printing to the command window
fprintf('Number of panels required for less than 1 percent error with Trapezoid: %i \n', trapzN); 
fprintf('Number of panels required for less than 1 percent error with Simpsons: %i \n\n', simpN); 

%% Problem 2
fprintf("-----------Problem 2-----------\n");

%Loading Data
load('Cp.mat');

%Defining constants
chord = 3; %m
aoa = 10 * pi /180; %rads
Vinf = 50; %m/s
rho = 1.225; %kg/m^3
Pinf = 101.3 * 10^3; %pa
Qinf = 0.5*rho*Vinf^2; %Dynamic Pressure

%Getting Cp from the structs
xVals = linspace(0, 1, 100); %100 values across the chord
upperCp = fnval(Cp_upper, xVals);
lowerCp = fnval(Cp_lower, xVals);

%Calculating the pressures from the coefficient of pressures
pUpper = (upperCp * Qinf);
pLower = (lowerCp * Qinf);

%Defining the thickness of the airfoil
y_t = @(x) ((.12*3)/.2)*(.2969.*sqrt(x./3)-.1260.*(x./3)-(.3516.*(x./3).^2)+(.2843.*(x./3).^3)-(.1036.*(x./3).^4));

%Integrating to get the upper Normal force
PuSum = pUpper(2:end) + pUpper(1:end-1);
Nupper = -1*sum(PuSum/2 .* diff(xVals));

%Integrating to get the lower Normal force
PlSum = pLower(2:end) + pLower(1:end-1);
Nlower = sum(PlSum/2 .* diff(xVals)); %Flip the sign


%Find the net normal force force
Nnet = Nupper + Nlower;


%Integrating to find the axial force
yVals = y_t(xVals); %Y values
deltaY = yVals(2:end) - yVals(1:end-1);

%Upper
Aupper = -1*sum(PuSum / 2 .* diff(yVals));

%Lower
Alower = sum(PlSum / 2 .* diff(yVals));

%Net
Anet = Aupper + Alower;



%THINGS TO DO
%Review normal and axial values
%Calculate lift and drag
Lift = Nnet * cos(aoa) - Anet * sin(aoa);
Drag = Nnet * sin(aoa) - Anet * cos(aoa);


%Printing to the command window
fprintf('Lift: %f N/m\n', Lift); 
fprintf('Drag: %f N/m\n', -1*Drag); 


%Determining the number of points required to get within 1% relative error
%of LIFT
%Exact solutions
liftExact = Lift;
liftError = 100: %Initiallizing the error to 100
i = 1; %Setting the iterator to 1

while(liftError > 1) %Once the error is less than 1, we exit the loop
    %Number of points in the for loop
    tempX = linspace(0,1,i);
    upperCp = fnval(Cp_upper, tempX);
    lowerCp = fnval(Cp_lower, tempX);
    
    %Calculating the pressures from the coefficient of pressures
    pUpper = (upperCp * Qinf);
    pLower = (lowerCp * Qinf);
    
    %Integrating to get the upper Normal force
    PuSum = pUpper(2:end) + pUpper(1:end-1);
    Nupper = -1*sum(PuSum/2 .* diff(xVals));
    
    %Integrating to get the lower Normal force
    PlSum = pLower(2:end) + pLower(1:end-1);
    Nlower = sum(PlSum/2 .* diff(xVals)); %Flip the sign
    
    %Find the net normal force force
    Nnet = Nupper + Nlower;
    
    %Integrating to find the axial force
    yVals = y_t(xVals); %Y values

    %Upper
    Aupper = -1*sum(PuSum / 2 .* diff(yVals));

    %Lower
    Alower = sum(PlSum / 2 .* diff(yVals));

    %Net
    Anet = Aupper + Alower;
end




%Defining the thickness of the airfoil
y_t = @(x) ((.12*3)/.2)*(.2969.*sqrt(x./3)-.1260.*(x./3)-(.3516.*(x./3).^2)+(.2843.*(x./3).^3)-(.1036.*(x./3).^4));

%Integrating to get the upper Normal force
PuSum = pUpper(2:end) + pUpper(1:end-1);
Nupper = -1*sum(PuSum/2 .* diff(xVals));

%Integrating to get the lower Normal force
PlSum = pLower(2:end) + pLower(1:end-1);
Nlower = sum(PlSum/2 .* diff(xVals)); %Flip the sign


%Find the net normal force force
Nnet = Nupper + Nlower;


%Integrating to find the axial force
yVals = y_t(xVals); %Y values
deltaY = yVals(2:end) - yVals(1:end-1);

%Upper
Aupper = -1*sum(PuSum / 2 .* diff(yVals));

%Lower
Alower = sum(PlSum / 2 .* diff(yVals));

%Net
Anet = Aupper + Alower;



%THINGS TO DO
%Review normal and axial values
%Calculate lift and drag
Lift = Nnet * cos(aoa) - Anet * sin(aoa);
Drag = Nnet * sin(aoa) - Anet * cos(aoa);






