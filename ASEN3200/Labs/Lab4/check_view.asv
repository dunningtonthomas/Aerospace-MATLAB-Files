function [observable, elevationAngle, cameraAngle] = check_view(r, facetNumber, F, V)
%CHECK_VIEW
%Author: Thomas Dunnington
% Description:
% This function accepts an initial state, facet number, list of facets, and a list of verticies in km and
% outputs the if the facet is observable, the elevation angle of the facet, and the camera angle of the
% facet.
% Inputs:
%   r - [3 by 1 ] spacecraft Cartesian position vector in the body frame [x, y, z]T
%   facetNumber - scalar, facet index
%   F - [n x 3] matrix of vertices that form each face
%   V - [m x 3] matrix of vertex locations in implied body frame
% Outputs:
%   observable - int, 0 for unobservable, 1 for observable
%   elevationAngle - scalar, elevation of spacecraft relative to the facet plane in radians
%   cameraAngle - scalar, angle of facet center relative to camera boresight

%Define FOV
FOV = pi / 9;

%Get the three vectors defining the face
face = F(facetNumber, :);
v1 = V(face(1), :);
vec2 = V(face(2), :);
vec3 = V(face(3), :);

v12 = vec2 - v1;
v13 = vec3 - v1;

%Defining the normal vector to the face
n = cross(v12, v13);
nhat = n ./ norm(n);

%Define vector from the center of bennu to the center of the face
rFace = (v1 + vec2 + vec3) ./ 3;

%Defining vector from the face to the spacecraft
rFS = r - rFace;

%Finding angle between rFS and the normal of the face
elevationAngle = pi/2 - acos(dot(rFS, nhat) / (norm(rFS) * norm(nhat)));

%Finding field of view angle
cameraAngle = acos(dot(-rFS, -r) / (norm(rFS) * norm(r)));

%Determining whether or not the facet is visible
if(elevationAngle >= 15*pi/180 && cameraAngle <= FOV)
    observable = 1;
else
    observable = 0;
end



%% Testing triangulation method
TR = triangulation(F, V);
rFVec = incenter(TR);
norms = faceNormal(TR);

%Getting the vector to the face and the face normal
rF = rFVec(facetNumber, :);
n = norms(facetNumber, :);

%Defining the vector from the face to the spacecraft
rFS = r - rF;

%Finding angle between rFS and the normal of the face
elevationAngle = 90 - acosd(dot(rFS, n) / (norm(rFS) * norm(n)));

%Finding field of view angle
cameraAngle = acosd(dot(-rFS, -r) / (norm(rFS) * norm(r)));

%Determining whether or not the facet is visible
observable = elevationAngle >= 15 && cameraAngle <= FOV;


%% Triangulation method with vectors
TR = triangulation(F, V);
rFVec = incenter(TR);
rVec = r.*ones(length(F(:,1)), 3);
norms = faceNormal(TR);

%Getting the vector to the face and the face normal
rF = rFVec;
n = norms;

%Defining the vector from the face to the spacecraft
rFS = rVec - rF;

%Finding angle between rFS and the normal of the face
elevationAngle = 90 - acosd(dot(rFS, n, 2) ./ (vecnorm(rFS, 2, 2) .* vecnorm(n, 2, 2)));

%Finding field of view angle
cameraAngle = acosd(dot(-1*rFS, -1*rVec, 2) ./ (vecnorm(rFS,2,2) .* vecnorm(rVec,2,2)));

%Determining whether or not the facet is visible
observable = elevationAngle >= 15 & cameraAngle <= FOV;

%Autograder output
% elevationAngle = elevationAngle(facetNumber);
% cameraAngle = cameraAngle(facetNumber);
% observable = observable(facetNumber);

end

